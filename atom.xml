<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AlJason</title>
  
  <subtitle>AlJason&#39;s Blogs</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://aljason.com/"/>
  <updated>2019-04-19T02:39:06.583Z</updated>
  <id>https://aljason.com/</id>
  
  <author>
    <name>AlJason</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git知识点整理</title>
    <link href="https://aljason.com/2019/04/17/Git/"/>
    <id>https://aljason.com/2019/04/17/Git/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-04-19T02:39:06.583Z</updated>
    
    <content type="html"><![CDATA[<p>【前言】Git(读音为/gɪt/)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。</p><hr><h2 id="1-Git基本概念。"><a href="#1-Git基本概念。" class="headerlink" title="1. Git基本概念。"></a>1. Git基本概念。</h2><ul><li><code>repository</code></li><li><code>config</code></li><li><code>init</code></li><li><code>clone</code></li><li><code>fetch</code></li><li><code>pull</code></li><li><code>commit</code></li><li><code>push</code></li><li><code>branch</code></li><li><code>head</code></li><li><code>tag</code></li><li><code>merge</code></li><li><code>conflict</code></li><li><code>diff</code></li><li><code>log</code></li><li><code>show</code></li><li><code>status</code></li></ul><h2 id="2-Git工作空间和文件状态"><a href="#2-Git工作空间和文件状态" class="headerlink" title="2. Git工作空间和文件状态"></a>2. Git工作空间和文件状态</h2><h3 id="1-工作空间"><a href="#1-工作空间" class="headerlink" title="(1).工作空间"></a>(1).工作空间</h3><p>![Git工作空间][Git/passage2-2.jpg]</p><p>左侧为工作区，右侧为版本库。</p><ul><li>工作区（<code>Working Directory</code>） 就是在电脑里能看到的目录，比如learngit文件夹就是一个工作区。</li><li>版本库（<code>Repository</code>）工作区有一个隐藏目录<code>.git</code>，是Git的版本库。</li></ul><p>在版本库中标记为<code>index</code>的区域为暂存区，标记为<code>master</code>的是Git为我们自动创建的第一个分支，代表的是目录树。此时<code>HEAD</code>实际是指向<code>master</code>分支的一个“游标”，所以图示的命令中出现HEAD的地方可以用<code>master</code>来替换。图中的objects标识的区域为git的对象库，实际位于<code>.git/objects</code>目录下。</p><ul><li>当对工作区修改（或新增）的文件执行<code>git add</code>命令时，暂存区的目录树会被更新，同时工作区修改（或新增）的文件内容会被写入到对象库中的一个新的对象中，而该对象的id被记录在暂存区的文件索引中。</li><li>当执行提交操作<code>git commit</code>时，暂存区的目录树会写到版本库（对象库）中，master分支会做相应的更新，即master最新指向的目录树就是提交时原暂存区的目录树。</li><li>当执行<code>git reset HEAD</code>命令时，暂存区的目录树会被重写，会被master分支指向的目录树所替换，但是工作区不受影响。</li><li>当执行<code>git rm --cached</code>命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当执行<code>git checkout .</code>或<code>git checkout --</code> 命令时，会用暂存区全部的文件或指定的文件替换工作区的文件。这个操作很危险，会清楚工作区中未添加到暂存区的改动。</li><li>当执行<code>git checkout HEAD .</code>或<code>git checkout HEAD</code>命令时，会用HEAD指向的master分支中的全部或部分文件替换暂存区和工作区中的文件。这个命令也是极度危险的。因为不但会清楚工作区中未提交的改动，也会清楚暂存区中未提交的改动。</li></ul><h3 id="1-文件状态"><a href="#1-文件状态" class="headerlink" title="(1).文件状态"></a>(1).文件状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：<strong>已提交(<code>committed</code>)</strong>、<strong>已修改(<code>modified</code>)</strong>和<strong>已暂存(<code>staged</code>)</strong>。</p><h2 id="3-Git配置系统级、全局、当前仓库用户名、邮箱的命令"><a href="#3-Git配置系统级、全局、当前仓库用户名、邮箱的命令" class="headerlink" title="3. Git配置系统级、全局、当前仓库用户名、邮箱的命令"></a>3. Git配置系统级、全局、当前仓库用户名、邮箱的命令</h2><p>系统级、全局、当前仓库选项分别是:仓库-system、-global、-local(或默认不填)</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"Jerry Mouse"</span><span class="token function">git</span> config --global user.email <span class="token string">"jerry@yiibai.com"</span></code></pre><p>列出Git设置</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --list<span class="token function">git</span> config -l</code></pre><h2 id="4-Git-fetch和pull的区别"><a href="#4-Git-fetch和pull的区别" class="headerlink" title="4. Git fetch和pull的区别"></a>4. Git fetch和pull的区别</h2><ul><li><code>git fetch</code>：相当于是从远程获取最新版本到本地，不会自动merge.</li><li><code>git pull</code>：相当于是从远程获取最新版本并merge到本地.</li></ul><h3 id="1-git-fetch示例："><a href="#1-git-fetch示例：" class="headerlink" title="(1). git fetch示例："></a>(1). git fetch示例：</h3><pre class=" language-bash"><code class="language-bash">Git fetch origin master<span class="token function">git</span> log -p master<span class="token punctuation">..</span>origin/master<span class="token function">git</span> merge origin/master</code></pre><p>以上命令的含义：</p><ul><li>首先从远程的<code>origin</code>的<code>master</code>主分支下载最新的版本到<code>origin/master</code>分支上</li><li>然后比较本地的<code>master</code>分支和<code>origin/master</code>分支的差别</li><li>最后进行合并</li><li>上述过程其实可以用以下更清晰的方式来进行：</li></ul><h3 id="1-git-pull示例："><a href="#1-git-pull示例：" class="headerlink" title="(1). git pull示例："></a>(1). git pull示例：</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> pull origin master</code></pre><p>上述命令其实相当于<code>git fetch</code>和<code>git merge</code>。在实际使用中，<code>git fetch</code>更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并。</p><h2 id="5-Git-reset和revert的却别"><a href="#5-Git-reset和revert的却别" class="headerlink" title="5. Git reset和revert的却别"></a>5. Git reset和revert的却别</h2><ul><li><code>git revert</code>是用一次新的commit来回滚之前的commit，<code>git reset</code>是直接删除指定的commit。 </li><li>在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为<code>git revert</code>是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是<code>git reset</code>是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。</li><li><code>git reset</code>是把HEAD向后移动了一下，而<code>git revert</code>是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</li><li>git revert与git reset最大的不同是，git revert 仅仅是撤销某次提交。</li></ul><p>另外，说一下<code>git revert</code>， <code>git reset –hard</code>和 <code>–soft</code>的区别</p><ul><li><code>git reset –mixed id</code>: 是将git的HEAD变了（也就是提交记录变了），但文件并没有改变，（也就是working tree并没有改变）。</li><li><code>git reset –soft id</code>: 实际上，是<code>git reset –mixed id</code>后，又做了一次<code>git add</code>。</li><li><code>git reset –herd id</code>: 是将git的HEAD变了，文件也变了。</li></ul><h2 id="6-Git-merge和reabse的相同点和不同点"><a href="#6-Git-merge和reabse的相同点和不同点" class="headerlink" title="6. Git merge和reabse的相同点和不同点"></a>6. Git merge和reabse的相同点和不同点</h2><p><code>merge</code>是合并的意思，<code>rebase</code>是复位基底的意思，相同点都是用来合并分支的。</p><p>![merge和rebase][Git/passage2-3.jpg]</p><p>不同点:</p><ul><li><code>merge</code>操作会生成一个新的节点，之前的提交分开显示。而<code>rebase</code>操作不会生成新的节点，是将两个分支融合成一个线性的提交。</li><li>解决冲突时。merge操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add 修改，commit就可以了。而<code>rebase</code>操作的话，会中断rebase,同时会提示去解决冲突。解决冲突后,将修改add后执行<code>git rebase –continue</code>继续操作，或者<code>git rebase –skip</code>忽略冲突。</li><li><code>git pull</code>和<code>git pull --rebase</code>区别：<code>git pull</code>做了两个操作分别是”获取”和”合并”。所以加了rebase就是以rebase的方式进行合并分支，默认为merge。</li></ul><p><strong>总结</strong>：选择 merge 还是 rebase？</p><ul><li>merge 是一个合并操作，会将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容</li><li>merge 的提交历史忠实地记录了实际发生过什么，关注点在真实的提交历史上面</li><li>rebase 并没有进行合并操作，只是提取了当前分支的修改，将其复制在了目标分支的最新提交后面</li><li>rebase 的提交历史反映了项目过程中发生了什么，关注点在开发过程上面</li><li>merge 与 rebase 都是非常强大的分支整合命令，没有优劣之分，使用哪一个应由项目和团队的开发需求决定</li><li>merge 和 rebase 还有很多强大的选项，可以使用 git help <command> 查看</li></ul><h2 id="7-Git-stash是什么？它的相关使用方式命令"><a href="#7-Git-stash是什么？它的相关使用方式命令" class="headerlink" title="7. Git stash是什么？它的相关使用方式命令"></a>7. Git stash是什么？它的相关使用方式命令</h2><ul><li>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。</li><li>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。</li><li>git stash pop –index stash@{0}: 恢复编号为0的进度的工作区和暂存区。</li><li>git stash apply stash@{1} 以将你指定版本号为stash@{1}的工作取出来</li><li>git stash drop[<stash>] 删除某一个进度，默认删除最新进度</stash></li><li>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。</li><li>git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 恢复工作进度</span><span class="token function">git</span> stash pop <span class="token punctuation">[</span>--index<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>stash<span class="token operator">></span><span class="token punctuation">]</span>--index 参数：不仅恢复工作区，还恢复暂存区<span class="token operator">&lt;</span>stash<span class="token operator">></span> 指定恢复某一个具体进度。如果没有这个参数，默认恢复最新进度<span class="token comment" spellcheck="true"># 这是git stash保存进度的完整命令形式</span><span class="token function">git</span> stash <span class="token punctuation">[</span>save message<span class="token punctuation">]</span> <span class="token punctuation">[</span>-k<span class="token operator">|</span>--no-keep-index<span class="token punctuation">]</span> <span class="token punctuation">[</span>--patch<span class="token punctuation">]</span>-k和--no-keep-index指定保存进度后，是否重置暂存区--patch 会显示工作区和HEAD的差异,通过编辑差异文件，排除不需要保存的内容。和git add -p命令类似使用save可以对进度添加备注<span class="token comment" spellcheck="true"># git stash save "这是保存的进度"</span></code></pre><h2 id="8-Git只从暂存区删除，从工作空间删除的命令分别是什么"><a href="#8-Git只从暂存区删除，从工作空间删除的命令分别是什么" class="headerlink" title="8. Git只从暂存区删除，从工作空间删除的命令分别是什么?"></a>8. Git只从暂存区删除，从工作空间删除的命令分别是什么?</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> --cached<span class="token function">git</span> <span class="token function">rm</span><span class="token function">git</span> commit</code></pre><h2 id="9-Git标签的使用"><a href="#9-Git标签的使用" class="headerlink" title="9. Git标签的使用"></a>9. Git标签的使用</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出现有的标签</span><span class="token function">git</span> tag<span class="token comment" spellcheck="true"># 打标签</span><span class="token function">git</span> tag -a v1.01 -m <span class="token string">"Relase version 1.01"</span><span class="token comment" spellcheck="true"># 查看相应标签的版本信息</span><span class="token function">git</span> show v1.4</code></pre><ul><li>-a 选项,创建一个含附注类型的标签</li><li>-m 选项,指定了对应的标签说明</li></ul><h2 id="9-Git分支的使用"><a href="#9-Git分支的使用" class="headerlink" title="9. Git分支的使用"></a>9. Git分支的使用</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看本地分支</span><span class="token function">git</span> branch<span class="token comment" spellcheck="true"># 查看远程分支</span><span class="token function">git</span> branch -r<span class="token comment" spellcheck="true"># 创建本地分支(注意新分支创建后不会自动切换为当前分支)</span><span class="token function">git</span> branch <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 切换分支</span><span class="token function">git</span> checkout <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 创建新分支并立即切换到新分支</span><span class="token function">git</span> checkout -b <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 强制删除一个分支</span><span class="token function">git</span> branch -D <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 合并分支(将名称为[name]的分支与当前分支合并)</span><span class="token function">git</span> merge <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 查看各个分支最后提交信息</span><span class="token function">git</span> br -v<span class="token comment" spellcheck="true"># 查看已经被合并到当前分支的分支</span><span class="token function">git</span> br --merged<span class="token comment" spellcheck="true"># 查看尚未被合并到当前分支的分支</span><span class="token function">git</span> br --no-merged</code></pre><h2 id="10-介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。"><a href="#10-介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。" class="headerlink" title="10. 介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。"></a>10. 介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。</h2><p>merge和rebase对于ours和theirs的定义是完全相反的。在merge时，ours指代的是当前分支，theirs代表需要被合并的分支。而在rebase过程中，ours指向了修改参考分支，theirs却是当前分支。因为rebase 隐含了一个<code>git checkout upstream</code>的过程，将<code>HEAD</code>从local分支变成了upstream分支。git会在rebase结束后撤销这个改变，但它已经不可避免地影响了冲突的状态，使rebase中ours和theirs的定义与merge 截然相反。因此，在使用ours与theirs时请格外小心。</p><h2 id="11-Git远程操作相关"><a href="#11-Git远程操作相关" class="headerlink" title="11. Git远程操作相关"></a>11. Git远程操作相关</h2><h3 id="1-clone"><a href="#1-clone" class="headerlink" title="(1). clone"></a>(1). clone</h3><blockquote><p>git clone &lt;版本库的网址&gt;<br>git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 克隆jQuery的版本库</span> <span class="token function">git</span> clone https://github.com/jquery/jquery.git <span class="token function">git</span> clone -o jQuery https://github.com/jquery/jquery.git</code></pre><h3 id="2-remote"><a href="#2-remote" class="headerlink" title="(2). remote"></a>(2). remote</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出所有远程主机</span><span class="token function">git</span> remote<span class="token comment" spellcheck="true"># 使用-v选项，可以参看远程主机的网址</span><span class="token function">git</span> remote -v<span class="token comment" spellcheck="true"># 可以查看该主机的详细信息</span><span class="token function">git</span> remote show <span class="token operator">&lt;</span>主机名<span class="token operator">></span><span class="token comment" spellcheck="true"># 添加远程主机</span><span class="token function">git</span> remote add <span class="token operator">&lt;</span>主机名<span class="token operator">></span> <span class="token operator">&lt;</span>网址<span class="token operator">></span><span class="token comment" spellcheck="true"># 删除远程主机</span><span class="token function">git</span> remote <span class="token function">rm</span> <span class="token operator">&lt;</span>主机名<span class="token operator">></span><span class="token comment" spellcheck="true"># 修改远程主机名称</span><span class="token function">git</span> remote <span class="token function">rename</span> <span class="token operator">&lt;</span>原主机名<span class="token operator">></span> <span class="token operator">&lt;</span>新主机名<span class="token operator">></span></code></pre><h3 id="3-fetch"><a href="#3-fetch" class="headerlink" title="(3). fetch"></a>(3). fetch</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 取回所有分支(branch)的更新到本地</span><span class="token function">git</span> fetch <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span><span class="token comment" spellcheck="true"># 取回某的特定分支的更新</span><span class="token function">git</span> fetch <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span> <span class="token operator">&lt;</span>分支名<span class="token operator">></span><span class="token comment" spellcheck="true"># 取回origin主机的master分支的更新</span><span class="token function">git</span> fetch origin master<span class="token comment" spellcheck="true"># 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支</span><span class="token function">git</span> merge origin/master<span class="token function">git</span> rebase origin/master</code></pre><h3 id="4-pull"><a href="#4-pull" class="headerlink" title="(4). pull"></a>(4). pull</h3><blockquote><p>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 取回origin主机的next分支，与本地的master分支合并</span><span class="token function">git</span> pull origin next:master<span class="token comment" spellcheck="true"># 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</span><span class="token function">git</span> pull origin next<span class="token comment" spellcheck="true"># 上面的命令实质上等同于先做git fetch，再做git merge。</span><span class="token function">git</span> fetch origin<span class="token function">git</span> merge origin/next<span class="token comment" spellcheck="true"># 合并需要采用rebase模式</span><span class="token function">git</span> pull --rebase <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span> <span class="token operator">&lt;</span>远程分支名<span class="token operator">></span>:<span class="token operator">&lt;</span>本地分支名<span class="token operator">></span></code></pre><h3 id="5-push"><a href="#5-push" class="headerlink" title="(5). push"></a>(5). push</h3><blockquote><p>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</p></blockquote><p><strong>注意</strong>:分支推送顺序的写法是”&lt;来源地&gt;:&lt;目的地&gt;”，所以git pull是”&lt;远程分支&gt;:&lt;本地分支&gt;”，而git push是”&lt;本地分支&gt;:&lt;远程分支&gt;”。</p><ul><li>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。</li><li>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建</span><span class="token function">git</span> push origin master<span class="token comment" spellcheck="true"># 省略了本地分支，以下等同，删除origin主机的master分支</span><span class="token function">git</span> push origin :master<span class="token function">git</span> push origin --delete master<span class="token comment" spellcheck="true"># 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略</span><span class="token function">git</span> push origin<span class="token comment" spellcheck="true"># 如果当前分支只有一个追踪分支，那么主机名都可以省略。</span><span class="token function">git</span> push<span class="token comment" spellcheck="true"># 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push</span><span class="token function">git</span> push -u origin master<span class="token comment" spellcheck="true"># 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机</span><span class="token function">git</span> push --all origin<span class="token comment" spellcheck="true"># 强制推送</span><span class="token function">git</span> push --force origin<span class="token comment" spellcheck="true"># git push不会推送标签(tag)，除非使用–tags选项</span><span class="token function">git</span> push origin --tags</code></pre><h2 id="12-Git-Flow使用简介"><a href="#12-Git-Flow使用简介" class="headerlink" title="12. Git Flow使用简介"></a>12. Git Flow使用简介</h2><p>就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范。三种广泛使用的工作流程：</p><ul><li>Git flow</li><li>Github flow</li><li>Gitlab flow</li></ul><p>三种工作流程，有一个共同点：都采用”功能驱动式开发”（Feature-driven development，简称FDD）。它指的是，需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。最早诞生、并得到广泛采用的一种工作流程，就是Git flow。</p><p>它最主要的特点有两个。首先，项目存在两个长期分支，分别是：主分支master、开发分支develop。其次，项目存在三种短期分支，分别是：功能分支（feature branch）、补丁分支（hotfix branch）、预发分支（release branch），一旦完成开发，它们就会被合并进develop或master，然后被删除。</p><h3 id="1-Git-Flow流程图"><a href="#1-Git-Flow流程图" class="headerlink" title="(1). Git Flow流程图"></a>(1). Git Flow流程图</h3><p>![Git Flow流程图][Git/passage2-4.jpg]</p><h3 id="2-Git-Flow常用的分支"><a href="#2-Git-Flow常用的分支" class="headerlink" title="(2). Git Flow常用的分支"></a>(2). Git Flow常用的分支</h3><ul><li><code>Production</code>分支。也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改。</li><li><code>Develop</code>分支。这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支。</li><li><code>Feature</code>分支。这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release。</li><li><code>Release</code>分支。当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支。</li><li><code>Hotfix</code>分支。当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release。</li></ul><h3 id="3-Git-Flow代码示例"><a href="#3-Git-Flow代码示例" class="headerlink" title="(3). Git Flow代码示例"></a>(3). Git Flow代码示例</h3><h4 id="a-创建develop分支"><a href="#a-创建develop分支" class="headerlink" title="a. 创建develop分支"></a>a. 创建develop分支</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> branch develop<span class="token function">git</span> push -u origin develop</code></pre><h4 id="b-开始新Feature开发"><a href="#b-开始新Feature开发" class="headerlink" title="b. 开始新Feature开发"></a>b. 开始新Feature开发</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b some-feature develop<span class="token comment" spellcheck="true"># Optionally, push branch to origin:</span><span class="token function">git</span> push -u origin some-feature<span class="token comment" spellcheck="true"># 做一些改动</span><span class="token function">git</span> status<span class="token function">git</span> add some-file<span class="token function">git</span> commit</code></pre><h4 id="c-完成Feature"><a href="#c-完成Feature" class="headerlink" title="c. 完成Feature"></a>c. 完成Feature</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> pull origin develop<span class="token function">git</span> checkout develop<span class="token function">git</span> merge --no-ff some-feature<span class="token function">git</span> push origin develop<span class="token function">git</span> branch -d some-feature<span class="token comment" spellcheck="true"># If you pushed branch to origin:</span><span class="token function">git</span> push origin --delete some-feature</code></pre><h4 id="d-开始Relase"><a href="#d-开始Relase" class="headerlink" title="d. 开始Relase"></a>d. 开始Relase</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b release-0.1.0 develop<span class="token comment" spellcheck="true"># Optional: Bump version number, commit</span><span class="token comment" spellcheck="true"># Prepare release, commit</span></code></pre><h4 id="e-完成Release"><a href="#e-完成Release" class="headerlink" title="e. 完成Release"></a>e. 完成Release</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout master<span class="token function">git</span> merge --no-ff release-0.1.0<span class="token function">git</span> push<span class="token function">git</span> checkout develop<span class="token function">git</span> merge --no-ff release-0.1.0<span class="token function">git</span> push<span class="token function">git</span> branch -d release-0.1.0<span class="token comment" spellcheck="true"># If you pushed branch to origin:</span><span class="token function">git</span> push origin --delete release-0.1.0   <span class="token function">git</span> tag -a v0.1.0 master<span class="token function">git</span> push --tags</code></pre><h4 id="f-开始Hotfix"><a href="#f-开始Hotfix" class="headerlink" title="f. 开始Hotfix"></a>f. 开始Hotfix</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b hotfix-0.1.1 master</code></pre><h4 id="g-完成Hotfix"><a href="#g-完成Hotfix" class="headerlink" title="g. 完成Hotfix"></a>g. 完成Hotfix</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout master<span class="token function">git</span> merge --no-ff hotfix-0.1.1<span class="token function">git</span> push<span class="token function">git</span> checkout develop<span class="token function">git</span> merge --no-ff hotfix-0.1.1<span class="token function">git</span> push<span class="token function">git</span> branch -d hotfix-0.1.1<span class="token function">git</span> tag -a v0.1.1 master<span class="token function">git</span> push --tags</code></pre><hr><p>【写在最后】本文转载自：<a href="https://blinkfox.github.io/2018/09/24/ruan-jian-gong-ju/git/git-zhi-shi-dian-zheng-li/" target="_blank" rel="noopener">Git知识点整理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【前言】Git(读音为/gɪt/)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-Git基本概念。&quot;&gt;&lt;a href=&quot;#1-Git基本概念。&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
      <category term="软件工具" scheme="https://aljason.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="https://aljason.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Blog搭建经验分享</title>
    <link href="https://aljason.com/2019/04/14/passage1/"/>
    <id>https://aljason.com/2019/04/14/passage1/</id>
    <published>2019-04-13T16:00:00.000Z</published>
    <updated>2019-04-17T07:37:18.015Z</updated>
    
    <content type="html"><![CDATA[<p>【前言】本博客的创建并不是完全由自己创造出来的，而是在借鉴前人的经验基础上，不断发现问题解决问题，不断完善而成的。这篇文章主要是为了将创建本博客过程中所参考的文章以及在创建过程当中所遇到问题的解决经验或者方法进行一个分享。</p><hr><h3 id="一、使用工具"><a href="#一、使用工具" class="headerlink" title="一、使用工具"></a>一、使用工具</h3><h4 id="Github"><a href="#Github" class="headerlink" title="- Github"></a>- <a href="https://github.com/" target="_blank" rel="noopener">Github</a></h4><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="- Node.js"></a>- <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js</a></h4><h4 id="Hexo"><a href="#Hexo" class="headerlink" title="- Hexo"></a>- <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a></h4><h3 id="二、Hexo基础开发"><a href="#二、Hexo基础开发" class="headerlink" title="二、Hexo基础开发"></a>二、Hexo基础开发</h3><h4 id="使用Hexo-Github一步步搭建属于自己的博客（基础）"><a href="#使用Hexo-Github一步步搭建属于自己的博客（基础）" class="headerlink" title="- 使用Hexo+Github一步步搭建属于自己的博客（基础）"></a>- <a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">使用Hexo+Github一步步搭建属于自己的博客（基础）</a></h4><blockquote><h5 id="在这篇基础教程中存在着几点需要注意的地方"><a href="#在这篇基础教程中存在着几点需要注意的地方" class="headerlink" title="在这篇基础教程中存在着几点需要注意的地方:"></a>在这篇基础教程中存在着几点需要注意的地方:<br></h5><p>1.第3点，创建Github项目仓库时，需要将仓库名与Github账号名保持一致，这样在后续的博客部署过程中才不会出现一些没必要的错误;<br><br>2.第3点，在对Github Pages进行配置的时候，如果在创建仓库的时候没有把Source创建在master branch下，那么就有在设置时将其选为master branch;<br><br>3.第5点，在创建id_rsa时，可以根据自己的需要设置属于自己的密钥;<br><br>4.第6点，在配置 Deployment时，由于.yml文件对于格式的要求非常严格，所以在配置的时候，在“type：”前面有两个空格，后面有一个空格。</p></blockquote><h3 id="三、Hexo进阶开发"><a href="#三、Hexo进阶开发" class="headerlink" title="三、Hexo进阶开发"></a>三、Hexo进阶开发</h3><h4 id="使用Hexo-Github一步步搭建属于自己的博客（进阶）"><a href="#使用Hexo-Github一步步搭建属于自己的博客（进阶）" class="headerlink" title="- 使用Hexo+Github一步步搭建属于自己的博客（进阶）"></a>- <a href="https://www.cnblogs.com/fengxiongZz/p/7707568.html" target="_blank" rel="noopener">使用Hexo+Github一步步搭建属于自己的博客（进阶）</a></h4><p>在这篇进阶开发的文章中，介绍了以Next主题为例的Hexo主题配置问题以及部分美化主题的操作</p><h4 id="Hexo的Next主题个性化教程-打造炫酷网站"><a href="#Hexo的Next主题个性化教程-打造炫酷网站" class="headerlink" title="- Hexo的Next主题个性化教程:打造炫酷网站"></a>- <a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">Hexo的Next主题个性化教程:打造炫酷网站</a></h4><h4 id="Valine评论系统"><a href="#Valine评论系统" class="headerlink" title="- Valine评论系统"></a>- <a href="https://www.jianshu.com/p/728a9594bb6c" target="_blank" rel="noopener">Valine评论系统</a></h4><h4 id="Valine评论框样式美化"><a href="#Valine评论框样式美化" class="headerlink" title="- Valine评论框样式美化"></a>- <a href="https://me.idealli.com/post/2d5da13e.html" target="_blank" rel="noopener">Valine评论框样式美化</a></h4><h4 id="去除valine的Powered-By"><a href="#去除valine的Powered-By" class="headerlink" title="- 去除valine的Powered By"></a>- <a href="https://blog.csdn.net/weixin_41196185/article/details/79180662" target="_blank" rel="noopener">去除valine的Powered By</a></h4><hr><h3 id="☆☆☆本博客使用的主题——Matery"><a href="#☆☆☆本博客使用的主题——Matery" class="headerlink" title="☆☆☆本博客使用的主题——Matery"></a><font color="red">☆☆☆本博客使用的主题——Matery</font></h3><h4 id="Hexo博客主题之hexo-theme-matery的介绍"><a href="#Hexo博客主题之hexo-theme-matery的介绍" class="headerlink" title="- Hexo博客主题之hexo-theme-matery的介绍"></a>- <a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">Hexo博客主题之hexo-theme-matery的介绍</a></h4><blockquote><p>Matery这个主题相对于Next主题而言，界面会更加的酷炫一点，但是在主题配置的时候也会相对麻烦一些，在配置过程中或有一些地方与配置Next主题时略有不同，大家在配置过程中如果有遇到什么问题，都可以在本文留言。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【前言】本博客的创建并不是完全由自己创造出来的，而是在借鉴前人的经验基础上，不断发现问题解决问题，不断完善而成的。这篇文章主要是为了将创建本博客过程中所参考的文章以及在创建过程当中所遇到问题的解决经验或者方法进行一个分享。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、使用工具&quot;&gt;
      
    
    </summary>
    
      <category term="前端，hexo" scheme="https://aljason.com/categories/%E5%89%8D%E7%AB%AF%EF%BC%8Chexo/"/>
    
    
      <category term="hexo，next，Matery，主题配置" scheme="https://aljason.com/tags/hexo%EF%BC%8Cnext%EF%BC%8CMatery%EF%BC%8C%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
</feed>
